<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Project Showcase - Quantum-Assisted Blockchain Consensus Simulation</title>
    <link rel="stylesheet" href="css/styles.css" />
    <link rel="stylesheet" href="css/showcase.css" />
    <link rel="icon" type="image/png" href="icon.png">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <script src="https://kit.fontawesome.com/ca7f2ffa51.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="navbar">
        <div class="logo">
          <a href="index.html" class="icon">
            <img src="icon.png" height="27px" width="27px" alt="Logo">
          </a>
        </div>
        <a href="index.html" class="nav-text">Home</a>
        <a href="#overview" class="nav-text">Overview</a>
        <a href="#gallery" class="nav-text">Gallery</a>
        <a href="#background" class="nav-text">Background</a>
        <a href="#implementation" class="nav-text">Implementation</a>
        <a href="#performance" class="nav-text">Performance</a>
      </div>

<div class="showcase__hero">
    <div class="showcase__wrapper">
        <div class="project-card">
            <div class="project-card__header">
                <div class="project-card__header-left">
                    <h1 class="project-title">Quantum-Assisted Blockchain Consensus Simulation</h1>
                    <div class="project-meta">
                        <span class="project-language">Python</span>
                        <span class="project-license">MIT License</span>
                    </div>
                </div>
                <div class="project-card__header-right">
                    <div class="project-stats">
                        <div class="stat-item">
                            <i class="fas fa-star"></i>
                            <span class="stat-count stars-count">0</span>
                        </div>
                        <div class="stat-item">
                            <i class="fas fa-code-branch"></i>
                            <span class="stat-count forks-count">0</span>
                        </div>
                        <div class="stat-item">
                            <i class="fas fa-eye"></i>
                            <span class="stat-count watchers-count">0</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="project-card__body">
                <p class="project-description">
                    A Python simulation exploring a blockchain consensus mechanism leveraging quantum state fidelity, implemented using Qiskit. Nodes generate unique quantum states from candidate blocks, compare them via fidelity measurements, and reach consensus based on state similarity thresholding.
                </p>
            </div>
            <div class="project-updated">
                <span>Updated <span class="updated-date">Recently</span></span>
            </div>
        </div>
    </div>
</div>

<div style="text-align: center; font-size: 2rem; margin: 20px 0;">
    <span>•</span>
    <span>•</span>
    <span>•</span>
</div>

<div class="showcase__content">
    <section id="overview" class="showcase__section">
        <h2>Overview</h2>
        <p>
            Implemented a <strong>simulation</strong> of a quantum-assisted blockchain consensus protocol using quantum fidelity checks and entanglement-based randomness to explore potential improvements in efficiency and security compared to purely classical approaches. The simulation is built in Python using the Qiskit framework.
        </p>
        <h3>Key Features</h3>
        <ul>
            <li>Quantum-based block validation using state vector fidelity checks (<code>qiskit.quantum_info.state_fidelity</code>).</li>
            <li>Potential for reduced computational complexity compared to classical Proof-of-Work (explored conceptually).</li>
            <li>Simulated sharing of quantum block statevectors between network nodes.</li>
            <li>Entanglement-based quantum random number generation using GHZ states for nonce creation.</li>
            <li>Consensus mechanism tolerant to f < n/2 faulty or disagreeing nodes (based on fidelity threshold agreement).</li>
        </ul>
    </section>

    <section id="gallery" class="showcase__section">
        <h2>Project Gallery</h2>
        <div class="image-gallery">
            <img src="images/blockchain_uml.png" alt="Blockchain Data Structure UML Diagram">
            <img src="images/quantum_circuit.png" alt="Illustrative Quantum Circuit Diagram">
        </div>
    </section>

    <section id="background" class="showcase__section">
        <h2>Background</h2>
        <p>
            This project simulates a consensus mechanism where nodes propose blocks and encode them into unique quantum states. Instead of a proof-of-work puzzle, each node prepares a multi-qubit quantum state derived from its candidate block using a custom <em>quantum hashing function</em>, then shares this state (simulated via direct statevector transfer in this implementation) with other nodes for verification via fidelity comparison.
        </p>

        <h3>Quantum Principles Utilized</h3>
        <p>The simulation leverages several quantum principles:</p>
        <ul>
            <li><strong>Quantum State Fidelity</strong>:
                \[
                    F(\rho, \sigma) = \left( \text{Tr} \sqrt{\sqrt{\rho} \sigma \sqrt{\rho}} \right)^2
                \]
                Here calculated between statevectors \( \lvert\psi_i\rangle \) and \( \lvert\psi_j\rangle \) as \( F(\lvert\psi_i\rangle, \lvert\psi_j\rangle) = \bigl|\langle\psi_i|\psi_j\rangle\bigr|^2 \), quantifying the similarity between block states.
            </li>
            <li><strong>Quantum Statevectors</strong>: Multi-qubit states \( \lvert \psi \rangle \) generated by the quantum hash function, representing the block's characteristics. These are simulated using Qiskit's `Statevector` class.</li>
            <li><strong>Entanglement (GHZ State)</strong>: Utilized within the `QuantumRandomNumberGenerator` to produce correlated random bits for nonce generation, leveraging states like:
                \[
                    \lvert GHZ_N \rangle = \frac{1}{\sqrt{2}} (\lvert 0 \rangle^{\otimes N} + \lvert 1 \rangle^{\otimes N})
                \]
            </li>
            <li><strong>Unitary Transformations</strong>: Complex, layered quantum circuits involving various gates (U, CNOT, RX, RY, RZ, P) act as unitary operators \( U_{\text{block}} \) to map classical block data to a quantum state: \( \lvert\psi_{\text{block}}\rangle = U_{\text{block}} \lvert 0 \rangle^{\otimes n} \).</li>
        </ul>

        <h3>Quantum Consensus Algorithm Steps (Implemented)</h3>
        <ol>
            <li><strong>Quantum Random Nonce Generation:</strong> Each node generates a random nonce using the entanglement-based `QuantumRandomNumberGenerator`.</li>
            <li><strong>Candidate Block Creation:</strong> Nodes build candidate blocks using transactions from their pool, the previous block's hash, and the generated nonce.</li>
            <li><strong>Quantum State Preparation:</strong> Each candidate block is mapped to a unique multi-qubit quantum statevector using the `QuantumHashFunction`, which applies a layered circuit based on block data (hash components, transaction metrics, nonce, etc.).</li>
            <li><strong>State Sharing (Simulated):</strong> Nodes exchange their computed statevectors directly with other nodes in the simulation.</li>
            <li><strong>Fidelity Computation:</strong> Each node calculates the quantum state fidelity between its own candidate block's statevector and the statevectors received from peers.</li>
            <li><strong>Winner Selection:</strong> Nodes identify an agreeing set based on high pairwise fidelity scores (e.g., \(F_{ij} \ge 0.9\)). A deterministic rule (e.g., lowest node ID in the agreeing set) selects a single proposer from this set.</li>
            <li><strong>Ledger Update:</strong> The block proposed by the selected winner is broadcast (simulated) and validated. Nodes that accept the block add it to their local blockchain and remove its transactions from their pool.</li>
        </ol>

    </section>

    <section id="implementation" class="showcase__section">
        <h2>Implementation Details</h2>
        <p>
            The simulation is implemented in Python 3 using the Qiskit library (specifically `qiskit` core, `qiskit-aer` for simulation, and `qiskit.quantum_info` for state manipulation). It features a standard blockchain data layer (`Block`, `Transaction`, `Blockchain` classes using `hashlib` for SHA-256) integrated with quantum components managed within each `QuantumConsensusNode`.
        </p>

        <h3>System Architecture</h3>
        <p>
            Each simulated node (`QuantumConsensusNode`) runs both classical and quantum components:
        </p>

        <h4>Classical Components:</h4>
        <ul>
            <li><strong>Blockchain Management:</strong> Stores the chain of blocks (`Blockchain` class), handles basic validation (index, previous hash), and manages the transaction pool.</li>
            <li><strong>Transaction Pool:</strong> Collects and stores pending transactions, preventing duplicates based on transaction ID.</li>
            <li><strong>Block Creation:</strong> Constructs candidate blocks by selecting transactions from the pool and incorporating metadata (index, timestamp, previous hash, nonce).</li>
            <li><strong>Ledger Update:</strong> Appends the validated, consensus-winning block to the local chain and removes its transactions from the pool.</li>
        </ul>

        <h4>Quantum Components (Simulated via Qiskit):</h4>
        <ul>
            <li><strong>Quantum Random Number Generator:</strong> Generates random integer nonces by preparing and measuring GHZ states on a number of qubits corresponding to the network size, using `qiskit.primitives.Sampler`.</li>
            <li><strong>Quantum Hash Function:</strong> Maps diverse block features (hash components, transaction count/volume/diversity, index, timestamp, nonce) into parameters for a layered quantum circuit involving `U`, `RY`, `RZ`, `CX`, `CZ`, `RX`, and `P` gates. This produces a unique multi-qubit `Statevector` for the block using `qiskit.quantum_info.Statevector`.</li>
            <li><strong>Simulated State Sharing:</strong> The protocol conceptually relies on sharing quantum states. In this simulation, this is achieved by directly passing the computed `Statevector` objects between `QuantumConsensusNode` instances.</li>
            <li><strong>Fidelity Check:</strong> Calculates the quantum state fidelity (`qiskit.quantum_info.state_fidelity`) between the statevectors of different candidate blocks to quantify their similarity.</li>
        </ul>

        <h3>Consensus Logic</h3>
        <p>
            Consensus is achieved when a sufficient number of nodes (more than half) produce candidate blocks whose quantum states have high fidelity (above a set threshold, e.g., 0.9) with each other. A deterministic rule (lowest node ID among the agreeing nodes) selects the definitive block proposer for that round, ensuring only one block is finalized even if multiple nodes had highly similar valid candidates.
        </p>

        <h3>Security Considerations (Conceptual)</h3>
        <p>
            While specific attacks were not simulated in this implementation, the design conceptually aims to leverage quantum properties. For instance, the reliance on unique quantum states for blocks could make certain classical manipulations harder. The use of fidelity checks provides a measure of agreement that is sensitive to small changes in the underlying block data. Further work would be required to simulate and analyze resilience against specific classical and quantum attacks (e.g., state manipulation, Sybil attacks).
        </p>

    </section>

    <section id="performance" class="showcase__section">
        <h2>Performance Observations (Simulation)</h2>
        <p>
            The simulation utilizes Qiskit Aer's `statevector_simulator` for ideal, noiseless execution of quantum circuits. Performance benchmarking against classical protocols like PoW or PoS was not part of this implementation but remains an area for future comparative analysis based on theoretical models or extended simulations.
        </p>

        <h3>Simulation Performance</h3>
        <p>
            The execution time of the simulation depends primarily on the number of nodes in the network, the number of qubits used by the `QuantumHashFunction` (`NUM_QUBITS_HASH`), the number of transactions processed, and the complexity of the quantum circuits generated. Key observations:
        </p>
        <ul>
            <li>Each consensus round involves statevector simulation for each node's candidate block and \(O(N^2)\) pairwise fidelity calculations for \(N\) nodes.</li>
            <li>Generating the quantum statevector via simulation is the most computationally intensive quantum step per node.</li>
            <li>Fidelity calculations between statevectors are relatively fast once the statevectors are available.</li>
            <li>Nonce generation using the QRNG involves circuit execution but is typically less demanding than the quantum hashing step for complex blocks.</li>
            <li>Preliminary runs indicate that consensus rounds complete within seconds on standard hardware for small network sizes (e.g., 3-5 nodes) and moderate qubit counts (e.g., 6-10 qubits), demonstrating the feasibility of simulating the core logic.</li>
        </ul>

        <h3>Technical Stack</h3>
        <div class="tech-icons">
            <i class="fab fa-python" title="Python"></i>
            <i class="fas fa-atom" title="Qiskit"></i>
        </div>
        <ul class="tech-list">
            <li><strong>Language:</strong> Python (3.x)</li>
            <li><strong>Quantum Framework:</strong> Qiskit (~0.4x)</li>
            <li><strong>Quantum Simulation:</strong> Qiskit Aer (`AerSimulator` with `method='statevector'`)</li>
            <li><strong>Libraries:</strong> NumPy, hashlib, json, dataclasses</li>
        </ul>
    </section>
</div>
<footer class="footer">
    <div class="footer__container">
      <div class="footer__content">
        <div class="footer__logo">
          <img src="icon.png" height="22px" width="22px" alt="Aaron McLean Logo">
          <h3>aaronmclean.xyz</h3>
        </div>
      </div>
      <div class="footer__copyright">
        <p>© <span id="current-year"></span> Aaron McLean</p>
      </div>
    </div>
</footer>

<div class="fullscreen-viewer">
    <img src="" alt="Fullscreen image" class="fullscreen-image">
    <div class="fullscreen-nav">
        <button class="fullscreen-prev">
            <i class="fas fa-chevron-left"></i>
          </button>
          <button class="fullscreen-next">
            <i class="fas fa-chevron-right"></i>
          </button>
    </div>
    <button class="fullscreen-close">×</button>
</div>
<script src="js/photo.js"></script>
<script src="js/showcase.js"></script>
<script src="js/github.js"></script>
<script src="js/track.js"></script>
<script>
    document.getElementById('current-year').textContent = new Date().getFullYear();
</script>

</body>
</html>